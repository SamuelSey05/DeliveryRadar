import { h, Host, } from '@stencil/core';
import { version } from '../../../package.json';
import { convertToCoordinates, DEFAULTS, isEmpty, parseCoordinates, resolveLanguageCode, sdk, t, W3W_REGEX, W3W_TEXTAREA_REGEX, W3W_TEXTAREA_PROPERTIES, what3wordsClients, } from '../../lib';
import { Status } from './components/status';
import { Suggestions } from './components/suggestions';
import { Tooltip } from './components/tooltip';
const tag = 'what3words-notes';
/**
 * @slot input - The textarea or input element to get suggestions from when typing
 * ```
 * <what3words-notes api-key="YOUR_API_KEY">
 *  <textarea slot="input"></textarea>
 *  <!-- OR -->
 *  <input slot="input" type="text" />
 * </what3words-notes>
 * ```
 * @slot label - The label element for the input slot element
 * ```
 * <what3words-notes api-key="YOUR_API_KEY">
 *  <label slot="label" for="delivery-notes">Delivery Notes/label>
 *  <textarea slot="input" name="delivery-notes"></textarea>
 * </what3words-notes>
 * ```
 * @slot tooltip - The tooltip content to display when the status icon is clicked
 * ```
 * <what3words-notes api-key="YOUR_API_KEY">
 *  <textarea slot="input"></textarea>
 *  <div slot="tooltip">
 *    <h1>Custom title</h1>
 *    <p>custom content</p>
 *  </div>
 * </what3words-notes>
 * ```
 */
export class What3wordsNotes {
  constructor() {
    var _a, _b;
    this.onSuggestionSelected = (suggestion) => () => {
      this.suggestionSelected.emit({ suggestion });
    };
    this.onMouseOver = (suggestion) => () => {
      const previousSuggestion = this.suggestions[this.hoverIndex] || null;
      if (!previousSuggestion || previousSuggestion.words !== suggestion.words) {
        this.suggestionHover.emit({ suggestion });
      }
    };
    this.onMouseOut = () => {
      this.setHoverIndex(-1);
    };
    this.addressFormat = 'slashes';
    this.showHintsTooltip = true;
    this.callback = '';
    this.apiKey = '';
    this.headers = '{}';
    this.baseUrl = (_b = (_a = sdk.api.clients.autosuggest['_config']) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'https://api.what3words.com';
    this.apiVersion = 'v3';
    this.typeaheadDelay = 300;
    this.language = '';
    this.searchFocus = undefined;
    this.nFocusResults = 3;
    this.clipToCountry = '';
    this.clipToBoundingBox = '';
    this.clipToCircle = '';
    this.clipToPolygon = '';
    this.value = '';
    this.suggestions = [];
    this.selectedSuggestions = [];
    this.updatingSelectedSuggestions = false;
    this.apiRequest = null;
    this.loading = false;
    this.hoverIndex = -1;
    this.clients = {};
    this.canvas = document.createElement('canvas');
    this.tooltipOpen = false;
  }
  /**
   * Watches for changes to the apiKey property
   * @param key The api key
   */
  setApiKey(key) {
    Object.values(this.clients).forEach(client => client.apiKey(key));
  }
  /**
   * Watches for changes to the baseUrl property
   * @param base_url The base url
   */
  setBaseUrl(host) {
    Object.values(this.clients).forEach(client => client.config({ host }));
  }
  /**
   * Watches for changes to the apiVersion property
   * @param apiVersion The version
   */
  setApiVersion(api_version) {
    Object.values(this.clients).forEach(client => client.config({ apiVersion: api_version }));
  }
  /**
   * Watches for changes to the headers property
   * @param value The headers value
   */
  setHeaders(value) {
    const componentHeaders = this.getComponentHeaders();
    const injectedHeaders = typeof value === 'string' ? JSON.parse(value) : value;
    Object.values(this.clients).forEach(client => client.config({ headers: Object.assign(Object.assign({}, injectedHeaders), componentHeaders) }));
  }
  /**
   * Watches for changes to the loading state
   */
  async handleLoadingChange(loading) {
    if (loading && !this.suggestions.length) {
      await this.showSuggestions();
    }
  }
  /**
   * Watches for changes to the suggestions state
   */
  async handleSuggestionsChange(newSuggestions, suggestions) {
    if (newSuggestions.length !== suggestions.length &&
      newSuggestions.length === 0) {
      await this.hideSuggestions();
    }
  }
  getComponentHeaders() {
    const meta = JSON.stringify({
      typeahead_delay: this.typeaheadDelay,
      component_session_id: window.what3words_session_id,
      slot: this.getInputSlotElement().tagName.toLowerCase(),
      origin: window.location.origin,
    });
    return {
      'X-W3W-AS-Component': `what3words-Notes-JS/${version} (${meta})`,
    };
  }
  async getRequestOptions(input) {
    const options = {
      input,
      language: this.language,
    };
    // validates the language
    options.language = resolveLanguageCode(this.language);
    if (this.searchFocus) {
      const [lat, lng] = this.searchFocus.split(',');
      options.focus = parseCoordinates(lat, lng);
    }
    if (!isEmpty(this.nFocusResults)) {
      options.nFocusResults = this.nFocusResults;
    }
    if (!isEmpty(this.clipToCountry)) {
      options.clipToCountry = this.clipToCountry.split(',');
    }
    if (!isEmpty(this.clipToBoundingBox)) {
      const [southLat, westLng, northLat, eastLng] = this.clipToBoundingBox.split(',');
      options.clipToBoundingBox = {
        northeast: parseCoordinates(northLat, eastLng),
        southwest: parseCoordinates(southLat, westLng),
      };
    }
    if (!isEmpty(this.clipToCircle)) {
      const [lat, lng, radius] = this.clipToCircle.split(',');
      options.clipToCircle = {
        center: parseCoordinates(lat, lng),
        radius: parseFloat(radius),
      };
    }
    if (!isEmpty(this.clipToPolygon)) {
      options.clipToPolygon = convertToCoordinates(this.clipToPolygon);
    }
    return options;
  }
  /**
   * @returns { HTMLTextAreaElement | HTMLInputElement }
   */
  getInputSlotElement() {
    const inputSlot = this.host.querySelector('[slot=input]');
    const isTextArea = inputSlot instanceof HTMLTextAreaElement;
    const isInput = inputSlot instanceof HTMLInputElement;
    if (!isTextArea && !isInput) {
      throw new Error('[slot=input] must be an instance of HTMLTextAreaElement or HTMLInputElement');
    }
    return inputSlot;
  }
  /**
   * Formats a what3words address based on the specified format.
   *
   * @param value - The what3words address to format.
   * @param format - The format to use for the address. Possible values are 'url' and 'slashes'.
   * @returns The formatted what3words address.
   */
  formatW3wAddress(value, format) {
    if (format === 'url') {
      return `https://w3w.co/${value.replace('///', '')}`;
    }
    return value;
  }
  /**
   * Look for a what3words address at the current cursor position in the input element and replace it with the selected suggestion
   *
   * @param { string } value The value to set
   */
  setInputValue(value) {
    const inputSlot = this.getInputSlotElement();
    const { w3w, start, end } = this.findW3wAtCursorPosition(inputSlot);
    if (w3w) {
      const formattedW3w = this.formatW3wAddress(value, this.addressFormat);
      const inputValue = inputSlot.value;
      const textBeforeW3w = inputValue.substring(0, start);
      const textAfterW3w = inputValue.substring(end, inputValue.length);
      const newVal = textBeforeW3w + formattedW3w + textAfterW3w;
      const newPos = (textBeforeW3w + formattedW3w).length;
      inputSlot.value = newVal;
      inputSlot.focus();
      inputSlot.selectionEnd = newPos;
      // remove from the suggestions list if text to replace exists
      const textToReplaceIndex = this.selectedSuggestions.indexOf(w3w);
      if (textToReplaceIndex !== -1)
        this.selectedSuggestions.splice(textToReplaceIndex, 1);
      const newSuggestions = [...this.selectedSuggestions, value];
      this.setSelectedSuggestions(newSuggestions, newSuggestions.length > 2);
    }
  }
  /**
   * Gets/sets the value state for the input element
   * @param { string } value The value to set
   */
  setValue(value) {
    this.value = value;
  }
  /**
   * Get/set the autosuggestions state value
   * @param { AutosuggestOption[] } suggestions The suggestions to set
   */
  setSuggestions(suggestions) {
    this.suggestions = suggestions;
  }
  /**
   * Sets selected w3w addresses
   * @param suggestions new list of selected w3w address
   * @param delayedUpdate simulates loading effect
   * @returns
   */
  setSelectedSuggestions(suggestions, delayedUpdate = false) {
    if (!delayedUpdate) {
      this.selectedSuggestions = suggestions;
      return;
    }
    this.updatingSelectedSuggestions = true;
    setTimeout(() => {
      this.selectedSuggestions = suggestions;
      this.updatingSelectedSuggestions = false;
    }, 500);
  }
  /**
   * Sets the loading state value
   * @param { boolean } loading The state to set
   */
  setLoading(loading) {
    this.loading = loading;
  }
  /**
   * Animation to show the suggestions list based on the the available space above the input
   */
  async showSuggestions() {
    const suggestions = this.host.querySelector(`.${tag}-suggestions`);
    if (!suggestions)
      return;
    const suggestionsHeight = suggestions.getBoundingClientRect().height;
    const hostBoundingRectTop = this.host.getBoundingClientRect().top;
    const fromTransform = hostBoundingRectTop > suggestionsHeight
      ? 'translateY(10px)'
      : 'translateY(-10px)';
    const keyframes = [
      { zIndex: -1, opacity: 0, transform: fromTransform },
      { zIndex: 100, opacity: 1, transform: 'translateY(0)' },
    ];
    const options = {
      duration: 150,
      easing: 'ease-in-out',
      fill: 'forwards',
    };
    return suggestions.animate(keyframes, options).finished;
  }
  /**
   * Animation to hide the suggestions list based on the the available space above the input
   */
  async hideSuggestions() {
    const suggestions = this.host.querySelector(`.${tag}-suggestions`);
    if (!suggestions)
      return;
    const suggestionsHeight = suggestions.getBoundingClientRect().height;
    const hostBoundingRectTop = this.host.getBoundingClientRect().top;
    const toTransform = hostBoundingRectTop > suggestionsHeight
      ? 'translateY(10px)'
      : 'translateY(-10px)';
    const keyframes = [{ zIndex: -1, opacity: 0, transform: toTransform }];
    const options = {
      duration: 150,
      easing: 'ease-in-out',
      fill: 'forwards',
    };
    return suggestions.animate(keyframes, options).finished;
  }
  /**
   * Animation to show the tooltip based on the the available space above the input
   */
  async openTooltip() {
    const tooltip = this.host.querySelector(`.${tag}-tooltip`);
    if (!tooltip)
      return;
    const tooltipHeight = tooltip.getBoundingClientRect().height;
    const hostBoundingRectTop = this.host.getBoundingClientRect().top;
    const fromTransform = hostBoundingRectTop > tooltipHeight
      ? 'translateY(10px)'
      : 'translateY(-10px)';
    const top = hostBoundingRectTop > tooltipHeight ? 'unset' : '2rem';
    const bottom = hostBoundingRectTop > tooltipHeight ? 'calc(100% + 0.5rem)' : 'unset';
    await tooltip.animate([
      {
        transform: fromTransform,
        opacity: 0,
        zIndex: -1,
        top,
        bottom,
      },
      {
        transform: 'translateY(0)',
        opacity: 1,
        zIndex: 100,
        top,
        bottom,
      },
    ], {
      duration: 150,
      easing: 'ease-in-out',
      fill: 'forwards',
    }).finished;
    this.tooltipOpen = true;
  }
  /**
   * Animation to hide the tooltip based on the the available space above the input
   */
  async closeTooltip() {
    const tooltip = this.host.querySelector(`.${tag}-tooltip`);
    if (!tooltip)
      return;
    const tooltipHeight = tooltip.getBoundingClientRect().height;
    const hostBoundingRectTop = this.host.getBoundingClientRect().top;
    const toTransform = hostBoundingRectTop > tooltipHeight
      ? 'translateY(10px)'
      : 'translateY(-10px)';
    await tooltip.animate([
      {
        zIndex: -1,
        opacity: 0,
        transform: toTransform,
      },
    ], {
      duration: 150,
      easing: 'ease-in-out',
      fill: 'forwards',
    }).finished;
    this.tooltipOpen = false;
  }
  /**
   * Gets/sets the hover index value
   * @param { number } hoverIndex The hover index value to set
   */
  setHoverIndex(hoverIndex) {
    this.hoverIndex = hoverIndex;
  }
  /**
   * Emits the could not retrieve co-ordinates error
   */
  emitFatalError() {
    var _a;
    this.apiError.emit({
      error: new Error((_a = t('error_message')) !== null && _a !== void 0 ? _a : DEFAULTS.fatalErrorMessage),
    });
  }
  clearApiError() {
    this.apiError.emit({ error: null });
  }
  /**
   * Asynchronously retrieves autosuggestion results for a given search string and sets the results against the
   * component state. This method is idempotent and has a timeout delay to throttle requests, waiting for the user to
   * stop typing.
   * @param value The search string to retrieve autosuggestions for.
   */
  async getAutosuggestions(value) {
    clearTimeout(this.apiRequest);
    const autosuggestClient = this.clients.autosuggest;
    if (!autosuggestClient) {
      const error = new Error('Autosuggest client not initialized');
      this.setLoading(false);
      this.apiError.emit({ error });
      throw error;
    }
    const options = await this.getRequestOptions(value);
    return autosuggestClient.run(options);
  }
  isValid3wa(value) {
    return W3W_REGEX.test(value);
  }
  extract3wa(value) {
    const [, words] = W3W_REGEX.exec(value);
    return words;
  }
  /**
   * Ensures that the what3words found on the input slot
   * Matches against the selectedSuggestions state
   */
  matchSelected3waFromInputSlot() {
    var _a, _b, _c;
    const inputSlot = this.getInputSlotElement();
    const w3wFromInput = ((_a = inputSlot.value) === null || _a === void 0 ? void 0 : _a.trim().length) === 0
      ? []
      : (_c = (_b = inputSlot.value) === null || _b === void 0 ? void 0 : _b.match(W3W_TEXTAREA_REGEX)) !== null && _c !== void 0 ? _c : [];
    const fromCurrentSuggestions = (suggestion, index) => suggestion === this.selectedSuggestions[index] ||
      this.selectedSuggestions.includes(suggestion);
    const selectedSuggestionsHasChanged = w3wFromInput.filter(fromCurrentSuggestions).length !==
      this.selectedSuggestions.length;
    if (selectedSuggestionsHasChanged) {
      const newSelected3wa = w3wFromInput.filter(fromCurrentSuggestions);
      this.setSelectedSuggestions(newSelected3wa);
    }
  }
  handleValueChanged({ detail: { value } }) {
    const valid = this.isValid3wa(value);
    this.matchSelected3waFromInputSlot();
    if (valid) {
      const words = this.extract3wa(value);
      this.setValue(words);
      this.valueValid.emit({
        value: DEFAULTS.prefix + words,
      });
    }
    else {
      if (this.apiRequest)
        clearTimeout(this.apiRequest);
      this.setValue(value);
      this.valueInvalid.emit({ value });
    }
  }
  handleValueValid({ detail: { value } }) {
    clearTimeout(this.apiRequest);
    this.clearApiError();
    this.setLoading(true);
    this.apiRequest = setTimeout(() => this.getAutosuggestions(value)
      .then(({ suggestions }) => {
      this.suggestionsChanged.emit({ suggestions });
    })
      .catch(() => {
      this.setSuggestions([]);
      this.emitFatalError();
    })
      .finally(() => {
      this.setLoading(false);
    }), this.typeaheadDelay);
  }
  handleValueInvalid() {
    clearTimeout(this.apiRequest);
    this.setLoading(false);
    this.setSuggestions([]);
  }
  async handleSuggestionsChanged({ detail: { suggestions } }) {
    this.setSuggestions(suggestions);
    this.setHoverIndex(-1);
  }
  async handleSuggestionSelected({ detail: { suggestion } }) {
    await this.hideSuggestions();
    this.setInputValue(DEFAULTS.prefix + suggestion.words);
    this.setValue(suggestion.words);
    this.setSuggestions([]);
    this.setHoverIndex(-1);
    this.clearApiError();
    await this.clients.autosuggest
      .onSelected(suggestion)
      .catch(error => this.apiError.emit({ error }));
  }
  handleSuggestionHover({ detail: { suggestion } }) {
    const suggestionsHoverIndex = this.suggestions.findIndex(s => s.words === suggestion.words);
    if (suggestionsHoverIndex > -1) {
      this.setHoverIndex(suggestionsHoverIndex);
    }
  }
  async handleBlur() {
    await Promise.all([this.closeTooltip(), this.hideSuggestions()]);
    this.setSuggestions([]);
  }
  // Event listeners
  handleInput(e) {
    const isNotLineBreak = !['insertLineBreak', 'insertParagraph'].includes(e.inputType);
    const isTextArea = e.target instanceof HTMLTextAreaElement;
    const isInput = e.target instanceof HTMLInputElement;
    if (isNotLineBreak && (isTextArea || isInput)) {
      const { w3w } = this.findW3wAtCursorPosition(e.target);
      this.valueChanged.emit({
        value: w3w,
      });
    }
  }
  handleKeyDown(e) {
    const keys = [
      'Escape',
      'ArrowLeft',
      'ArrowRight',
      'ArrowDown',
      'ArrowUp',
      'Enter',
    ];
    if (!keys.includes(e.key))
      return;
    const { suggestions, loading, value = '', hoverIndex, suggestionSelected, } = this;
    const suggestion = suggestions.find(s => s.words === value.replace(/$\/*/, ''));
    switch (e.key) {
      case 'Escape':
        this.getInputSlotElement().blur();
        this.setHoverIndex(-1);
        break;
      case 'ArrowUp':
        if (suggestions.length > 0) {
          e.preventDefault();
          if (suggestions[hoverIndex - 1]) {
            this.setHoverIndex(hoverIndex - 1);
          }
          else
            this.setHoverIndex(suggestions.length - 1);
        }
        break;
      case 'ArrowDown':
        if (suggestions.length > 0) {
          e.preventDefault();
          if (suggestions[hoverIndex + 1]) {
            this.setHoverIndex(hoverIndex + 1);
          }
          else
            this.setHoverIndex(0);
        }
        break;
      case 'ArrowRight':
      case 'ArrowLeft':
        // Disable arrow right and arrow left when suggestions are shown
        // Since the the calculation for the suggestions list style is dependent
        // on where the cursor position is located
        if (loading || suggestions.length > 0) {
          e.preventDefault();
        }
        break;
      case 'Enter':
        // Prevent line breaks in textarea and form submission when selecting a suggestion
        if (suggestions.length > 0) {
          e.preventDefault();
        }
        if (suggestions[hoverIndex] || suggestion) {
          suggestionSelected.emit({
            suggestion: suggestions[hoverIndex] || suggestion,
          });
        }
        this.setHoverIndex(-1);
        break;
    }
  }
  handleContextMenu(e) {
    // Dismiss suggestions if context menu is triggered
    if (e.target !== this.host.querySelector(`.${tag}-suggestions`)) {
      this.hideSuggestions();
      this.setSuggestions([]);
    }
  }
  handleWindowClick(e) {
    if (!this.host.contains(e.target) ||
      e.target === this.getInputSlotElement()) {
      this.closeTooltip();
    }
    // Dismiss suggestions if the target is outside of the suggestions popup
    if (e.target !== this.host.querySelector(`.${tag}-suggestions`)) {
      this.hideSuggestions();
      this.setSuggestions([]);
    }
  }
  async handleScroll(e) {
    if (!this.loading && this.suggestions.length > 0) {
      await Promise.all([this.closeTooltip(), this.hideSuggestions()]);
      this.setSuggestions([]);
    }
  }
  getSuggestionsStyle(inputSlot, labelContainer) {
    var _a, _b;
    const { top: inputRectTop } = inputSlot.getBoundingClientRect();
    const hasSpaceAboveInputForSuggestions = inputRectTop > 145;
    const labelHeight = (_b = (_a = labelContainer === null || labelContainer === void 0 ? void 0 : labelContainer.getBoundingClientRect()) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : 0;
    const { left: cursorLeft, right: cursorRight, top: cursorTop, bottom: cursorBottom, } = this.getCursorPosition(inputSlot);
    const bottom = hasSpaceAboveInputForSuggestions
      ? `calc(100% - ${cursorTop}px - ${labelHeight}px + 4px)`
      : undefined;
    const top = hasSpaceAboveInputForSuggestions
      ? undefined
      : `calc(${cursorBottom + labelHeight}px + 4px)`;
    const left = cursorLeft ? `${cursorLeft}px` : undefined;
    const right = cursorRight ? `${cursorRight}px` : undefined;
    return {
      bottom,
      top,
      right,
      left,
    };
  }
  /**
   * Finds the what3words address at the current cursor position in the textarea element.
   */
  findW3wAtCursorPosition(inputSlot) {
    var _a;
    const cursorPos = inputSlot.selectionStart;
    const inputValue = inputSlot.value;
    const w3wFromInput = inputValue.match(W3W_TEXTAREA_REGEX);
    if (!w3wFromInput)
      return { w3w: '' };
    const w3w = (_a = w3wFromInput.find(m => {
      const start = cursorPos - m.length;
      const end = start + m.length;
      const value = inputValue.substring(start, end);
      return value === m;
    })) !== null && _a !== void 0 ? _a : '';
    const start = cursorPos - w3w.length;
    const end = start + w3w.length;
    return { start, end, w3w };
  }
  async connectedCallback() {
    // Configure service clients
    const config = {
      apiVersion: this.apiVersion,
      headers: Object.assign(Object.assign({}, this.getComponentHeaders()), JSON.parse(this.headers)),
      host: this.baseUrl,
    };
    const transport = await import('@what3words/api').then(m => m.fetchTransport());
    if (!this.apiKey) {
      throw new Error('a What3words API key is required, you can get one at https://accounts.what3words.com/select-plan');
    }
    this.clients = {
      autosuggest: what3wordsClients.autosuggest(this.apiKey, config, transport),
      convertToCoordinates: what3wordsClients.convertToCoordinates(this.apiKey, config, transport),
    };
  }
  disconnectedCallback() {
    clearTimeout(this.apiRequest);
  }
  async componentWillLoad() {
    if (this.callback && typeof window[this.callback] === 'function') {
      window[this.callback]();
    }
    const { value: initial_value } = this;
    if (W3W_REGEX.test(initial_value)) {
      const { suggestions } = await this.getAutosuggestions(initial_value);
      return this.suggestionsChanged.emit({ suggestions });
    }
  }
  getCursorPosition(inputSlot) {
    const inputSlotMirror = document.createElement('div');
    const inputSlotStyle = getComputedStyle(inputSlot);
    // Copy the input slot style to the mirror element
    // This provides accuracy of the measurement get from the mirror element
    W3W_TEXTAREA_PROPERTIES.forEach(prop => {
      inputSlotMirror.style[prop] = inputSlotStyle[prop];
    });
    inputSlotMirror.style.position = 'absolute';
    inputSlotMirror.style.whiteSpace = 'pre-wrap';
    inputSlotMirror.style.wordBreak = 'break-word';
    inputSlotMirror.style.visibility = 'hidden';
    const position = inputSlot.selectionStart;
    const normalizedText = inputSlot.value.normalize().substring(0, position);
    inputSlotMirror.textContent = normalizedText;
    document.body.appendChild(inputSlotMirror);
    const cursorSpan = document.createElement('span');
    inputSlotMirror.appendChild(cursorSpan);
    const { offsetTop, offsetLeft } = cursorSpan;
    document.body.removeChild(inputSlotMirror);
    const lineHeight = this.getLineHeight(inputSlot);
    const inputWidth = parseFloat(inputSlotStyle.width);
    const left = offsetLeft - inputSlot.scrollLeft;
    const right = inputWidth - offsetLeft - inputSlot.scrollLeft;
    const bottom = offsetTop + lineHeight - inputSlot.scrollTop;
    const top = bottom - lineHeight;
    const isRtl = inputSlotStyle.direction === 'rtl';
    const result = {
      left: isRtl ? undefined : left,
      right: isRtl ? right : undefined,
      top,
      bottom,
    };
    return result;
  }
  getLineHeight(element) {
    const elementStyle = getComputedStyle(element);
    const lineHeight = elementStyle.lineHeight;
    if (!['inherit', 'initial', 'normal'].includes(lineHeight)) {
      return parseFloat(lineHeight);
    }
    if (['normal', 'initial'].includes(lineHeight)) {
      return parseFloat(elementStyle.fontSize) * 1.2;
    }
    if (lineHeight === 'inherit') {
      const parent = element.parentElement;
      if (parent) {
        return this.getLineHeight(parent);
      }
    }
  }
  render() {
    var _a;
    const { onSuggestionSelected, onMouseOver, onMouseOut } = this;
    const value = (_a = this.value) !== null && _a !== void 0 ? _a : '';
    const isLoading = this.loading;
    const inputSlot = this.getInputSlotElement();
    const selected3waCount = this.selectedSuggestions.length;
    const isLoadingSelected3waCount = this.updatingSelectedSuggestions;
    const hasSelectedSuggestions = this.selectedSuggestions.length > 0;
    const labelContainer = this.host.querySelector(`.${tag}-label`);
    const suggestionsStyle = inputSlot
      ? this.getSuggestionsStyle(inputSlot, labelContainer)
      : {};
    return (h(Host, { class: {
        [tag]: !!tag,
        loading: isLoading,
        valid: hasSelectedSuggestions,
      } }, h("fieldset", { class: { [`${tag}-input-wrapper`]: !!tag }, "data-testid": "input-wrapper" }, h("div", { class: { [`${tag}-label`]: !!tag } }, h("slot", { name: "label" }), h(Status, { tag: tag, isLoadingSelected3waCount: isLoadingSelected3waCount, selected3waCount: selected3waCount, showHintsTooltip: this.showHintsTooltip, toggleTooltip: () => this.tooltipOpen ? this.closeTooltip() : this.openTooltip() })), h("slot", { name: "input" }), h(Tooltip, { tag: tag, onClose: () => this.closeTooltip() })), h(Suggestions, { style: suggestionsStyle, tag: tag, value: value, hoverIndex: this.hoverIndex, loading: isLoading, suggestions: this.suggestions, onSuggestionSelected: onSuggestionSelected.bind(this), onMouseOver: onMouseOver.bind(this), onMouseOut: onMouseOut.bind(this), onClose: () => this.hideSuggestions() })));
  }
  static get is() { return "what3words-notes"; }
  static get originalStyleUrls() {
    return {
      "$": ["notes.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["notes.css"]
    };
  }
  static get properties() {
    return {
      "addressFormat": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "W3wAddressFormat",
          "resolved": "\"slashes\" | \"url\"",
          "references": {
            "W3wAddressFormat": {
              "location": "local",
              "path": "/home/circleci/project/packages/javascript/src/components/notes/notes.tsx"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "default",
              "text": "slashes"
            }],
          "text": "The format to display the what3words address in\n- `slashes` - e.g. `///filled.count.soap` (default)\n- `url` - e.g. `https://w3w.co/filled.count.soap`"
        },
        "attribute": "address-format",
        "reflect": false,
        "defaultValue": "'slashes'"
      },
      "showHintsTooltip": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "default",
              "text": "true"
            }],
          "text": "Show the what3words hints tooltip when clicking on the what3words status icon"
        },
        "attribute": "show-hints-tooltip",
        "reflect": false,
        "defaultValue": "true"
      },
      "callback": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The callback function to execute when the component is loaded"
        },
        "attribute": "callback",
        "reflect": false,
        "defaultValue": "''"
      },
      "apiKey": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The what3words API key to use for the what3words API requests"
        },
        "attribute": "api-key",
        "reflect": false,
        "defaultValue": "''"
      },
      "headers": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The headers to include in the what3words API requests"
        },
        "attribute": "headers",
        "reflect": false,
        "defaultValue": "'{}'"
      },
      "baseUrl": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The base URL for the what3words API requests"
        },
        "attribute": "base-url",
        "reflect": false,
        "defaultValue": "sdk.api.clients.autosuggest['_config']?.host ??\n    'https://api.what3words.com'"
      },
      "apiVersion": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "import('@what3words/api').ApiVersion",
          "resolved": "ApiVersion.Version1 | ApiVersion.Version2 | ApiVersion.Version3",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "default",
              "text": "\"v3\""
            }],
          "text": "The API version to use for the what3words API requests"
        },
        "attribute": "api-version",
        "reflect": false,
        "defaultValue": "'v3' as import('@what3words/api').ApiVersion"
      },
      "typeaheadDelay": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "default",
              "text": "300"
            }],
          "text": "The delay in milliseconds to wait after the user has finished typing before making an autosuggest request"
        },
        "attribute": "typeahead-delay",
        "reflect": false,
        "defaultValue": "300"
      },
      "language": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"en\""
            }],
          "text": "The language to return the results in"
        },
        "attribute": "language",
        "reflect": false,
        "defaultValue": "''"
      },
      "searchFocus": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "`${number},${number}`",
          "resolved": "`${number},${number}`",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"51.5412,-0.2477\""
            }],
          "text": "The focus point to prioritize results around. If not provided, the user's current location is used."
        },
        "attribute": "search-focus",
        "reflect": false
      },
      "nFocusResults": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "default",
              "text": "3"
            }],
          "text": "The number of results to return"
        },
        "attribute": "n-focus-results",
        "reflect": false,
        "defaultValue": "3"
      },
      "clipToCountry": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"GB\""
            }],
          "text": "Clip the results to a specific country"
        },
        "attribute": "clip-to-country",
        "reflect": false,
        "defaultValue": "''"
      },
      "clipToBoundingBox": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"51.521,-0.205,51.576,-0.105\""
            }],
          "text": "Clip the results to a specific bounding box"
        },
        "attribute": "clip-to-bounding-box",
        "reflect": false,
        "defaultValue": "''"
      },
      "clipToCircle": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"51.521,-0.205,1000\""
            }],
          "text": "Clip the results to a specific circle"
        },
        "attribute": "clip-to-circle",
        "reflect": false,
        "defaultValue": "''"
      },
      "clipToPolygon": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "\"51.521,-0.205,51.576,-0.105,51.576,-0.205\""
            }],
          "text": "Clip the results to a specific polygon"
        },
        "attribute": "clip-to-polygon",
        "reflect": false,
        "defaultValue": "''"
      }
    };
  }
  static get states() {
    return {
      "value": {},
      "suggestions": {},
      "selectedSuggestions": {},
      "updatingSelectedSuggestions": {},
      "apiRequest": {},
      "loading": {},
      "hoverIndex": {},
      "clients": {},
      "canvas": {},
      "tooltipOpen": {}
    };
  }
  static get events() {
    return [{
        "method": "valueChanged",
        "name": "valueChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "{ value: \"filled.count.s\" }"
            }],
          "text": "Emitted when the input value changes"
        },
        "complexType": {
          "original": "InputValuePayload",
          "resolved": "{ value: string; }",
          "references": {
            "InputValuePayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "valueValid",
        "name": "valueValid",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "{ value: \"filled.count.soap\" }"
            }],
          "text": "Emitted when the input value is a valid what3words address"
        },
        "complexType": {
          "original": "InputValuePayload",
          "resolved": "{ value: string; }",
          "references": {
            "InputValuePayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "valueInvalid",
        "name": "valueInvalid",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "{ value: \"filled,count,s\" }"
            }],
          "text": "Emitted when the input value is not a valid what3words address"
        },
        "complexType": {
          "original": "InputValuePayload",
          "resolved": "{ value: string; }",
          "references": {
            "InputValuePayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "suggestionSelected",
        "name": "suggestionSelected",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [{
              "name": "example",
              "text": "{ suggestion: { words: \"filled.count.soap\", [...] } }"
            }],
          "text": "Emitted when a suggestion is selected"
        },
        "complexType": {
          "original": "SuggestionPayload",
          "resolved": "{ suggestion: AutosuggestOption; }",
          "references": {
            "SuggestionPayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "suggestionsChanged",
        "name": "suggestionsChanged",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emitted when the suggestions change"
        },
        "complexType": {
          "original": "SuggestionsPayload",
          "resolved": "{ suggestions: AutosuggestOption[]; }",
          "references": {
            "SuggestionsPayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "suggestionHover",
        "name": "suggestionHover",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emitted when a suggestion is hovered over"
        },
        "complexType": {
          "original": "SuggestionPayload",
          "resolved": "{ suggestion: AutosuggestOption; }",
          "references": {
            "SuggestionPayload": {
              "location": "import",
              "path": "../autosuggest/autosuggest"
            }
          }
        }
      }, {
        "method": "apiError",
        "name": "apiError",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emitted when a what3words API error occurs"
        },
        "complexType": {
          "original": "{ error: Error | null }",
          "resolved": "{ error: Error; }",
          "references": {
            "Error": {
              "location": "global"
            }
          }
        }
      }];
  }
  static get elementRef() { return "host"; }
  static get watchers() {
    return [{
        "propName": "apiKey",
        "methodName": "setApiKey"
      }, {
        "propName": "baseUrl",
        "methodName": "setBaseUrl"
      }, {
        "propName": "apiVersion",
        "methodName": "setApiVersion"
      }, {
        "propName": "headers",
        "methodName": "setHeaders"
      }, {
        "propName": "loading",
        "methodName": "handleLoadingChange"
      }, {
        "propName": "suggestions",
        "methodName": "handleSuggestionsChange"
      }];
  }
  static get listeners() {
    return [{
        "name": "valueChanged",
        "method": "handleValueChanged",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "valueValid",
        "method": "handleValueValid",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "valueInvalid",
        "method": "handleValueInvalid",
        "target": undefined,
        "capture": false,
        "passive": false
      }, {
        "name": "suggestionsChanged",
        "method": "handleSuggestionsChanged",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "suggestionSelected",
        "method": "handleSuggestionSelected",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "suggestionHover",
        "method": "handleSuggestionHover",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "blur",
        "method": "handleBlur",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "input",
        "method": "handleInput",
        "target": undefined,
        "capture": true,
        "passive": true
      }, {
        "name": "keydown",
        "method": "handleKeyDown",
        "target": undefined,
        "capture": true,
        "passive": false
      }, {
        "name": "contextmenu",
        "method": "handleContextMenu",
        "target": "window",
        "capture": true,
        "passive": true
      }, {
        "name": "click",
        "method": "handleWindowClick",
        "target": "window",
        "capture": true,
        "passive": true
      }, {
        "name": "scroll",
        "method": "handleScroll",
        "target": undefined,
        "capture": true,
        "passive": true
      }];
  }
}
